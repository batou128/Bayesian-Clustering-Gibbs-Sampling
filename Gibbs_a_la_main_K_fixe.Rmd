
```{r setup, include=FALSE}
library(LaplacesDemon)
library(ggplot2)
library(label.switching)

```



```{r}
# Les constantes
gal = MASS::galaxies
gal = gal/1000
N = length(gal)
K = 3
Nbrep = 13000
burnin = 3000
kappa0 = 0.1
mu0 = 20.8
nu0 = 100
Lambda0 = 100
alpha = rep(3,K)
```


```{r}
f <- function(xi, mut, sigmat, pit){ 
  K = length(pit)
  val = 0
  for(k in 1:K){
    val = val + pit[k] * dnorm(xi, mean=mut[k],sd = sqrt(sigmat[k]))
  }
  return(val)
}
```


```{r}
# Les fonctions utiles pour les conjugate prior
m <- function(Z){
  return(colSums(Z))
}

xbarre <- function(Z){
# Si une composante est nulle metrre xbarre à 0
 div = 1/m(Z)
 div[which(m(Z) == 0)] = 0
 return(t(div * t(Z) %*% gal)) 
}

epsilon <- function(Z){
  return((kappa0*mu0+m(Z)*xbarre(Z))/(kappa0+m(Z)))
}

schapeau <- function(Z){
  return(colSums(Z *  (matrix(rep(gal,K),ncol = K) -  t(matrix(rep(xbarre(Z),N),nrow =K)))**2))
}
```


```{r}
# Tirage des valeurs en suivant le papier

tirerSigma = function(Z){
  sigmas = rep(0,K)
  valeurs_tirage = 1/2 * (Lambda0 + schapeau(Z)+ (kappa0*m(Z))/(kappa0+m(Z)) *(xbarre(Z)-mu0)**2)
  
  for(i in 1:K){
    sigmas[i] = rinvgamma(1, (nu0+m(Z)[i])/2, valeurs_tirage[i])
  }
  
  return(sigmas)
}

tirerMu = function(Z, sigma){
  mus = rep(0,K)
  valeur = sigma/(kappa0+m(Z))
  valeur[is.infinite(valeur)] = 1e300
  for(i in 1:K){
    mus[i] = rnorm(1, epsilon(Z)[i], sqrt(valeur[i]))
  }
  return(mus)
}


tirerPi = function(Z){
  return(rdirichlet(1, alpha + m(Z)))
}

tirerZ = function(Pi, Mu, Sigma){
  
  Z = matrix(0, nrow=N, ncol=K)
  
  l = matrix(0, nrow=N, ncol=K)
    
  for(k in 1:K) {
    l[,k] = Pi[k] * dnorm(gal, Mu[k], sqrt(Sigma[k]))
  }
  
  l_sum = rowSums(l)
  
  l = l / l_sum
  
  for (i in 1:N) {
    Z[i,] = t(rmultinom(1, 1, l[i,])) 
  }
  return(Z)
}
```


```{r}
# Initialisation de Z
d = dist(gal)
clust = hclust(d, method = "ward.D")
groupe_init = cutree(clust, k= K)

Z = matrix(0, nrow=N, ncol=K)
for(i in 1:N){
  Z[i,groupe_init[i]] = 1
}
```

```{r}
#Boucle pour Gibbs
sigmaGibbs = matrix(rep(0,Nbrep*K), ncol=K)
muGibbs = matrix(rep(0,Nbrep*K), ncol=K)
piGibbs = matrix(rep(0,Nbrep*K), ncol=K)
ZGibbs = array(data=rep(0, Nbrep*K*N), dim=c(N,K,Nbrep))

for(j in 1:Nbrep){
  
  sigma2 = tirerSigma(Z)
  sigmaGibbs[j,] = sigma2
  
  mu = tirerMu(Z, sigma2)
  muGibbs[j,] = mu
  
  pi = tirerPi(Z)
  piGibbs[j,] = pi
  Z = tirerZ(pi, mu, sigma2)
  ZGibbs[,,j] = Z
}
```


```{r}
muGibbs = muGibbs[- rep(1:burnin),]
sigmaGibbs = sigmaGibbs[- rep(1:burnin),]
piGibbs = piGibbs[- rep(1:burnin),]
ZGibbs = ZGibbs[,,- rep(1:burnin)]

print(colMeans(piGibbs))
print(colMeans(muGibbs))
print(colMeans(sigmaGibbs))
```


```{r}
#Convergence avant label switching
DFMu = as.data.frame(muGibbs)
DFMu$index = 1:nrow(DFMu)

DFPi = as.data.frame(piGibbs)
DFPi$index = 1:nrow(DFPi)

DFSigma = as.data.frame(sigmaGibbs)
DFSigma$index = 1:nrow(DFSigma)

g3 = ggplot(DFMu)+
  geom_line(aes(x=index,y=V1), color='blue')+
  geom_line(aes(x=index,y=V2), color = 'green')+
  geom_line(aes(x=index,y=V3), color = "yellow")
plot(g3)

g4 = ggplot(DFPi)+
  geom_line(aes(x=index,y=V1), color='blue')+
  geom_line(aes(x=index,y=V2), color = 'green')+
  geom_line(aes(x=index,y=V3), color = "yellow")
plot(g4)

g5 = ggplot(DFSigma)+
  geom_line(aes(x=index,y=V1), color='blue')+
  geom_line(aes(x=index,y=V2), color = 'green')+
  geom_line(aes(x=index,y=V3), color = "yellow")
plot(g5)
```
```{r}
# Matrice contenant le groupe associer à chaque galaxies à chaque itération
# A optimiser
Group = matrix(rep(0,N*(Nbrep-burnin)), ncol = N)

for( i in 1:(Nbrep-burnin)){
  for(j in 1:N){
    Group[i,j] = which.max(ZGibbs[j,,i])  
  }
}

```

```{r}
# Label switching
P = array(data=rep(0, (Nbrep-burnin)*K*N), dim=c(Nbrep-burnin,N,K))
  
  for(t in 1:(Nbrep-burnin)) {
    l = matrix(0, nrow=N, ncol=K)
    
    for(k in 1:K) {
      l[,k] = piGibbs[t,k] * dnorm(gal, muGibbs[t,k], sqrt(sigmaGibbs[t,k]))
    }
    
    l_sum = rowSums(l)
    P[t,,] = l / l_sum
  }
  
  
  p <- label.switching(method = "STEPHENS",z = Group, p= P,K = K)
  
  
  # Creation de l'array MCMC contenant tous nos paramètres:
  MCMC = array(data=rep(0,(Nbrep-burnin)*K*3),dim=c(Nbrep-burnin,K,3))
  MCMC[,,1] = muGibbs
  MCMC[,,2] = sigmaGibbs
  MCMC[,,3] = piGibbs
  
  
  # On permute désormais
  PERMUT = permute.mcmc(MCMC, p$permutations$STEPHENS)
  
  MuP = PERMUT$output[,,1]
  SigmaP = PERMUT$output[,,2]
  PiP = PERMUT$output[,,3]
```

```{r}
# Convergence après label switching
DFMu = as.data.frame(MuP)
DFMu$index = 1:nrow(DFMu)

DFPi = as.data.frame(PiP)
DFPi$index = 1:nrow(DFPi)

DFSigma = as.data.frame(SigmaP)
DFSigma$index = 1:nrow(DFSigma)

g3 = ggplot(DFMu)+
  geom_line(aes(x=index,y=V1), color='blue')+
  geom_line(aes(x=index,y=V2), color = 'green')+
  geom_line(aes(x=index,y=V3), color = "yellow")
plot(g3)

g4 = ggplot(DFPi)+
  geom_line(aes(x=index,y=V1), color='blue')+
  geom_line(aes(x=index,y=V2), color = 'green')+
  geom_line(aes(x=index,y=V3), color = "yellow")
plot(g4)

g5 = ggplot(DFSigma)+
  geom_line(aes(x=index,y=V1), color='blue')+
  geom_line(aes(x=index,y=V2), color = 'green')+
  geom_line(aes(x=index,y=V3), color = "yellow")
plot(g5)
```

```{r}
ProbMU <- function(MU){
  i = dnorm(MU[1], 0, 0.01, log=TRUE)
  for(j in 2:K){
    i = i + dnorm(MU[j], 0, 0.01, log=TRUE)
  }
  return(i)
}
```

```{r}
ProbSIGMA <- function(SIGMA){
  i = dinvgamma(SIGMA[1], 0.01, 0.01, log=TRUE)
  for(j in 2:K){
    i = i + dinvgamma(SIGMA[j], 0.01, 0.01, log=TRUE)
  }
  return(i)
}
```

```{r}

ProbPI <- function(PI){
  i = ddirichlet(PI, rep(1,K), log=TRUE)
  return(i)
}
```

```{r}
ProbLikelihood <- function(mu, sigma, pi, X){
  
  val = 1
  for (i in 1:length(gal)){
    tmp = 0
    for(j in 1:K){
      
      tmp = tmp + pi[j]*dnorm(X[i],mu[j],sigma[j])
      
    }
    val = val * tmp
  }
  return(log(val))
  
}
```


```{r}
bestMU = MuP[1,]
bestSIGMA = SigmaP[1,]
bestPI = PiP[1,]
bestG = Group[1,]
bestTheta = ProbMU(bestMU)+ProbSIGMA(bestSIGMA)+ProbPI(bestPI)+ProbLikelihood(bestMU, bestSIGMA, bestPI, gal)

for(i in 2:(Nbrep-burnin)){
  tmpTheta = ProbMU(MuP[i,])+ProbSIGMA(SigmaP[i,])+ProbPI(PiP[i,])+ProbLikelihood(MuP[i,], SigmaP[i,], PiP[i,], gal)
  if(tmpTheta > bestTheta){
    bestMU = MuP[i,]
    bestSIGMA = SigmaP[i,]
    bestPI = PiP[i,]
    bestG = Group[i,]
    bestTheta = tmpTheta
  }
}

df = as.data.frame(gal)

g1 <- ggplot(df,aes(x=gal))+
  geom_histogram(mapping = aes(x = gal, y=..density..), fill="steelblue", colour="black", binwidth=2)+
  stat_function(fun = f, args = list(pit = bestPI, mut = bestMU, sigmat = bestSIGMA))+
  xlab("galaxies")+
  geom_point(aes(x=gal, y=0), color= bestG)+
  scale_color_gradient()
plot(g1)
```

